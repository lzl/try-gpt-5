<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Balls Bouncing in Rotating Polygon</title>
    <style>
      :root {
        --bg: #0b0e14;
        --panel-bg: rgba(17, 20, 28, 0.85);
        --text: #e6e6e6;
        --muted: #9aa4b2;
        --accent: #4cc3ff;
        --accent-2: #9bffa7;
        --danger: #ff6b6b;
        --shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      }

      html, body {
        height: 100%;
        margin: 0;
        background: var(--bg);
        color: var(--text);
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      }

      .app {
        position: relative;
        height: 100%;
        width: 100%;
        overflow: hidden;
      }

      canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
        background: var(--bg);
      }

      .controls {
        position: absolute;
        top: 14px;
        right: 14px;
        width: min(380px, 94vw);
        max-height: calc(100% - 28px);
        overflow: auto;
        background: var(--panel-bg);
        border: 1px solid rgba(255,255,255,0.06);
        border-radius: 14px;
        box-shadow: var(--shadow);
        backdrop-filter: blur(8px);
        padding: 14px;
      }

      .controls h2 {
        margin: 0 0 8px 0;
        font-size: 18px;
        letter-spacing: 0.3px;
      }

      .controls .row {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 10px 12px;
        align-items: center;
        margin: 8px 0;
      }

      .controls label {
        font-size: 12px;
        color: var(--muted);
      }

      .controls input[type="range"],
      .controls input[type="number"],
      .controls select,
      .controls input[type="color"] {
        width: 160px;
        background: rgba(255,255,255,0.06);
        color: var(--text);
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 8px;
        padding: 6px 8px;
        font-size: 12px;
      }

      .controls input[type="range"] {
        height: 26px;
        padding: 0;
      }

      .controls .grid-2 {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px 10px;
        margin-top: 8px;
      }

      .controls .btns {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 8px;
        margin-top: 10px;
      }

      button {
        background: linear-gradient(135deg, rgba(76,195,255,0.15), rgba(155,255,167,0.12));
        border: 1px solid rgba(255,255,255,0.12);
        color: var(--text);
        border-radius: 10px;
        padding: 9px 10px;
        font-size: 12px;
        cursor: pointer;
      }

      button:hover { filter: brightness(1.05); }
      button:active { filter: brightness(0.97); }

      .hint {
        margin-top: 8px;
        font-size: 11px;
        color: var(--muted);
      }

      .inline {
        display: inline-flex;
        gap: 8px;
        align-items: center;
      }

      .switch {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        user-select: none;
      }

      .switch input {
        width: auto;
        height: auto;
      }

      .kpi {
        margin-top: 6px;
        font-size: 11px;
        color: var(--muted);
      }
    </style>
  </head>
  <body>
    <div class="app">
      <canvas id="sim"></canvas>

      <div class="controls" id="controls">
        <h2>Balls in Rotating Polygon</h2>

        <div class="row">
          <label for="sides">Polygon sides (3-12)</label>
          <input id="sides" type="range" min="3" max="12" step="1" value="6" />
        </div>

        <div class="row">
          <label for="rotSpeed">Rotation speed (°/s)</label>
          <input id="rotSpeed" type="range" min="-360" max="360" step="1" value="45" />
        </div>

        <div class="row">
          <label for="count">Ball count</label>
          <input id="count" type="range" min="1" max="300" step="1" value="80" />
        </div>

        <div class="row">
          <label for="gravity">Gravity (px/s²)</label>
          <input id="gravity" type="range" min="0" max="2000" step="10" value="700" />
        </div>

        <div class="row">
          <label for="restitution">Bounce</label>
          <input id="restitution" type="range" min="0" max="1" step="0.01" value="0.9" />
        </div>

        <div class="row">
          <label for="wallFriction">Wall friction</label>
          <input id="wallFriction" type="range" min="0" max="1" step="0.01" value="0.02" />
        </div>

        <div class="grid-2">
          <label for="minR">Min radius</label>
          <input id="minR" type="range" min="2" max="20" step="1" value="4" />
          <label for="maxR">Max radius</label>
          <input id="maxR" type="range" min="4" max="30" step="1" value="10" />
        </div>

        <div class="row">
          <label for="speed">Initial speed</label>
          <input id="speed" type="range" min="0" max="800" step="10" value="280" />
        </div>

        <div class="row">
          <label for="polyRadius">Polygon radius (%)</label>
          <input id="polyRadius" type="range" min="20" max="95" step="1" value="70" />
        </div>

        <div class="row">
          <label for="edgeWidth">Edge width</label>
          <input id="edgeWidth" type="range" min="1" max="6" step="1" value="2" />
        </div>

        <div class="row">
          <label for="trail">Trail fade (0=off)</label>
          <input id="trail" type="range" min="0" max="1" step="0.01" value="0.1" />
        </div>

        <div class="row">
          <label for="bgColor">Background</label>
          <input id="bgColor" type="color" value="#0b0e14" />
        </div>

        <div class="row">
          <span class="switch">
            <input id="showPolygonFill" type="checkbox" />
            <label for="showPolygonFill">Fill polygon</label>
          </span>
          <span class="switch">
            <input id="pause" type="checkbox" />
            <label for="pause">Pause</label>
          </span>
        </div>

        <div class="row">
          <span class="switch">
            <input id="ballCollisions" type="checkbox" checked />
            <label for="ballCollisions">Ball collisions</label>
          </span>
        </div>

        <div class="btns">
          <button id="reset">Reset</button>
          <button id="randomize">Randomize</button>
          <button id="export">Export PNG</button>
        </div>

        <div class="kpi" id="kpi">FPS: — | Balls: —</div>
        <div class="hint">Tip: Negative rotation speed spins clockwise. Resize window to fit.</div>
      </div>
    </div>

    <script>
      (() => {
        const canvas = document.getElementById('sim');
        const ctx = canvas.getContext('2d');
        const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

        const TWO_PI = Math.PI * 2;

        const controls = {
          sides: document.getElementById('sides'),
          rotSpeed: document.getElementById('rotSpeed'),
          count: document.getElementById('count'),
          gravity: document.getElementById('gravity'),
          restitution: document.getElementById('restitution'),
          wallFriction: document.getElementById('wallFriction'),
          minR: document.getElementById('minR'),
          maxR: document.getElementById('maxR'),
          speed: document.getElementById('speed'),
          polyRadius: document.getElementById('polyRadius'),
          edgeWidth: document.getElementById('edgeWidth'),
          trail: document.getElementById('trail'),
          bgColor: document.getElementById('bgColor'),
          showPolygonFill: document.getElementById('showPolygonFill'),
          pause: document.getElementById('pause'),
          reset: document.getElementById('reset'),
          randomize: document.getElementById('randomize'),
          export: document.getElementById('export'),
          kpi: document.getElementById('kpi'),
          ballCollisions: document.getElementById('ballCollisions'),
        };

        const state = {
          width: 0,
          height: 0,
          center: { x: 0, y: 0 },
          theta: 0,
          omega: 0, // rad/s
          polygonRadiusPx: 0,
          edges: [], // computed each frame from theta
          balls: [],
          lastTime: performance.now(),
          fpsAccumulator: 0,
          fpsFrames: 0,
          fps: 0,
          paused: false,
          settings: {
            sides: Number(controls.sides.value),
            rotationSpeedDeg: Number(controls.rotSpeed.value),
            gravity: Number(controls.gravity.value),
            restitution: Number(controls.restitution.value),
            wallFriction: Number(controls.wallFriction.value),
            minR: Number(controls.minR.value),
            maxR: Number(controls.maxR.value),
            initialSpeed: Number(controls.speed.value),
            polygonRadiusPercent: Number(controls.polyRadius.value),
            edgeWidth: Number(controls.edgeWidth.value),
            trailAlpha: Number(controls.trail.value),
            bgColor: controls.bgColor.value,
            showPolygonFill: controls.showPolygonFill.checked,
            ballCount: Number(controls.count.value),
            subSteps: 2,
            airDrag: 0.0,
            ballCollisions: true,
          },
        };

        function setCanvasSize() {
          const { clientWidth, clientHeight } = canvas;
          state.width = clientWidth;
          state.height = clientHeight;
          canvas.width = Math.floor(clientWidth * DPR);
          canvas.height = Math.floor(clientHeight * DPR);
          ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
          state.center.x = state.width / 2;
          state.center.y = state.height / 2;
          updatePolygonRadiusPx();
        }

        function updatePolygonRadiusPx() {
          const p = state.settings.polygonRadiusPercent / 100;
          const minHalf = Math.min(state.width, state.height) / 2;
          state.polygonRadiusPx = Math.max(20, minHalf * p);
        }

        // Utility vector ops
        const V = {
          add: (a, b) => ({ x: a.x + b.x, y: a.y + b.y }),
          sub: (a, b) => ({ x: a.x - b.x, y: a.y - b.y }),
          mul: (a, s) => ({ x: a.x * s, y: a.y * s }),
          dot: (a, b) => a.x * b.x + a.y * b.y,
          len: (a) => Math.hypot(a.x, a.y),
          norm: (a) => {
            const l = Math.hypot(a.x, a.y) || 1;
            return { x: a.x / l, y: a.y / l };
          },
          perpCW: (a) => ({ x: a.y, y: -a.x }),
          perpCCW: (a) => ({ x: -a.y, y: a.x }),
        };

        function buildPolygon(theta, sides, radius, center) {
          const verts = [];
          const step = TWO_PI / sides;
          // Start angle so a vertex is at top-ish
          const start = -Math.PI / 2 + theta;
          for (let i = 0; i < sides; i++) {
            const a = start + i * step;
            verts.push({
              x: center.x + Math.cos(a) * radius,
              y: center.y + Math.sin(a) * radius,
            });
          }
          // Build edges with outward normals
          const edges = [];
          for (let i = 0; i < sides; i++) {
            const v0 = verts[i];
            const v1 = verts[(i + 1) % sides];
            const edge = V.sub(v1, v0);
            let n = V.norm(V.perpCW(edge)); // candidate
            const mid = { x: (v0.x + v1.x) / 2, y: (v0.y + v1.y) / 2 };
            const toCenter = V.sub(state.center, mid);
            // choose outward: should point away from center
            if (V.dot(n, toCenter) > 0) n = V.mul(n, -1);
            const c = V.dot(n, v0);
            const len = V.len(edge);
            const dir = V.mul(edge, 1 / (len || 1));
            edges.push({ v0, v1, n, c, len, dir });
          }
          return { verts, edges };
        }

        function randomBetween(min, max) {
          return min + Math.random() * (max - min);
        }

        function hsvToRgb(h, s, v) {
          const c = v * s;
          const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
          const m = v - c;
          let r = 0, g = 0, b = 0;
          if (0 <= h && h < 60) [r, g, b] = [c, x, 0];
          else if (60 <= h && h < 120) [r, g, b] = [x, c, 0];
          else if (120 <= h && h < 180) [r, g, b] = [0, c, x];
          else if (180 <= h && h < 240) [r, g, b] = [0, x, c];
          else if (240 <= h && h < 300) [r, g, b] = [x, 0, c];
          else [r, g, b] = [c, 0, x];
          r = Math.round((r + m) * 255);
          g = Math.round((g + m) * 255);
          b = Math.round((b + m) * 255);
          return `rgb(${r}, ${g}, ${b})`;
        }

        function createBalls(count) {
          const balls = [];
          const attemptsMax = 2000;
          let attempts = 0;
          const { minR, maxR, initialSpeed } = state.settings;
          const { edges } = buildPolygon(state.theta, state.settings.sides, state.polygonRadiusPx, state.center);

          function insideForRadius(p, r) {
            for (let i = 0; i < edges.length; i++) {
              const e = edges[i];
              if (V.dot(e.n, p) > e.c - r) return false;
            }
            return true;
          }

          while (balls.length < count && attempts++ < attemptsMax) {
            const r = Math.round(randomBetween(minR, maxR));
            // Sample in bounding circle then check polygon
            const a = Math.random() * TWO_PI;
            const rr = Math.random() ** 0.5 * (state.polygonRadiusPx - r - 2);
            const p = { x: state.center.x + Math.cos(a) * rr, y: state.center.y + Math.sin(a) * rr };
            if (!insideForRadius(p, r)) continue;
            // Avoid overlaps (simple check)
            let ok = true;
            for (let j = 0; j < balls.length; j++) {
              const b = balls[j];
              if (Math.hypot(b.p.x - p.x, b.p.y - p.y) < b.r + r + 1) { ok = false; break; }
            }
            if (!ok) continue;
            const dir = Math.random() * TWO_PI;
            const speed = initialSpeed * (0.5 + Math.random());
            const v = { x: Math.cos(dir) * speed, y: Math.sin(dir) * speed };
            const hue = (Math.random() * 360);
            const color = hsvToRgb(hue, 0.75, 1.0);
            const m = r * r * r; // mass proportional to volume
            balls.push({ p, v, r, color, m });
          }
          // If we couldn't place all without overlap, fill rest anyway
          while (balls.length < count) {
            const r = Math.round(randomBetween(minR, maxR));
            const a = Math.random() * TWO_PI;
            const rr = Math.random() ** 0.5 * (state.polygonRadiusPx - r - 2);
            const p = { x: state.center.x + Math.cos(a) * rr, y: state.center.y + Math.sin(a) * rr };
            const dir = Math.random() * TWO_PI;
            const speed = initialSpeed * (0.5 + Math.random());
            const v = { x: Math.cos(dir) * speed, y: Math.sin(dir) * speed };
            const hue = (Math.random() * 360);
            const color = hsvToRgb(hue, 0.75, 1.0);
            const m = r * r * r; // mass proportional to volume
            balls.push({ p, v, r, color, m });
          }
          return balls;
        }

        function updateSettingsFromUI() {
          const s = state.settings;
          s.sides = Math.max(3, Math.min(12, Number(controls.sides.value)));
          s.rotationSpeedDeg = Number(controls.rotSpeed.value);
          s.gravity = Number(controls.gravity.value);
          s.restitution = Number(controls.restitution.value);
          s.wallFriction = Number(controls.wallFriction.value);
          s.minR = Math.min(Number(controls.minR.value), Number(controls.maxR.value));
          s.maxR = Math.max(Number(controls.minR.value), Number(controls.maxR.value));
          s.initialSpeed = Number(controls.speed.value);
          s.polygonRadiusPercent = Number(controls.polyRadius.value);
          s.edgeWidth = Number(controls.edgeWidth.value);
          s.trailAlpha = Number(controls.trail.value);
          s.bgColor = controls.bgColor.value;
          s.showPolygonFill = controls.showPolygonFill.checked;
          s.ballCount = Number(controls.count.value);
          s.ballCollisions = controls.ballCollisions.checked;
          state.paused = controls.pause.checked;
          updatePolygonRadiusPx();
          state.omega = (s.rotationSpeedDeg * Math.PI / 180);
        }

        function resetSimulation(recreateBalls = true) {
          updateSettingsFromUI();
          if (recreateBalls) {
            state.balls = createBalls(state.settings.ballCount);
          }
        }

        function projectPointToSegment(p, a, b, dir, len) {
          const ap = V.sub(p, a);
          const t = Math.max(0, Math.min(len, V.dot(ap, dir)));
          return { x: a.x + dir.x * t, y: a.y + dir.y * t };
        }

        function step(dt) {
          const s = state.settings;
          const sub = Math.max(1, s.subSteps | 0);
          const h = dt / sub;
          const gravity = { x: 0, y: s.gravity };

          for (let iter = 0; iter < sub; iter++) {
            // advance rotation
            state.theta += state.omega * h;
            // keep theta in [-PI, PI] for stability
            if (state.theta > Math.PI) state.theta -= TWO_PI;
            if (state.theta < -Math.PI) state.theta += TWO_PI;

            const { edges } = buildPolygon(state.theta, s.sides, state.polygonRadiusPx, state.center);
            state.edges = edges;

            for (let i = 0; i < state.balls.length; i++) {
              const b = state.balls[i];

              // ensure mass exists (backward safety if balls created before mass was added)
              if (b.m == null) b.m = b.r * b.r * b.r;

              // integrate
              b.v.x += gravity.x * h;
              b.v.y += gravity.y * h;
              // air drag
              const drag = Math.max(0, 1 - s.airDrag * h);
              b.v.x *= drag; b.v.y *= drag;
              b.p.x += b.v.x * h;
              b.p.y += b.v.y * h;

              // resolve against all edges, possibly multiple passes for corners
              for (let pass = 0; pass < 2; pass++) {
                for (let ei = 0; ei < edges.length; ei++) {
                  const e = edges[ei];
                  const sdist = V.dot(e.n, b.p) - (e.c - b.r);
                  if (sdist > 0) {
                    // push inside
                    b.p.x -= e.n.x * sdist;
                    b.p.y -= e.n.y * sdist;

                    // contact point on segment
                    const cpt = projectPointToSegment(b.p, e.v0, e.v1, e.dir, e.len);
                    // wall velocity at contact due to rotation: v = omega x r
                    const rvec = { x: cpt.x - state.center.x, y: cpt.y - state.center.y };
                    const vwall = { x: -state.omega * rvec.y, y: state.omega * rvec.x };

                    // relative velocity
                    const vrel = { x: b.v.x - vwall.x, y: b.v.y - vwall.y };
                    const vn = V.dot(vrel, e.n);
                    if (vn > 0) {
                      // reflect normal component with restitution
                      const j = (1 + s.restitution) * vn;
                      vrel.x -= j * e.n.x;
                      vrel.y -= j * e.n.y;
                      // reduce tangential component by wall friction
                      const vtDot = V.dot(vrel, e.n);
                      const vnorm = { x: e.n.x * vtDot, y: e.n.y * vtDot };
                      const vtan = { x: vrel.x - vnorm.x, y: vrel.y - vnorm.y };
                      vrel.x = vnorm.x + vtan.x * (1 - s.wallFriction);
                      vrel.y = vnorm.y + vtan.y * (1 - s.wallFriction);

                      // back to world velocity
                      b.v.x = vrel.x + vwall.x;
                      b.v.y = vrel.y + vwall.y;
                    }
                  }
                }
              }
            }

            // ball-ball collisions (toggleable)
            if (s.ballCollisions) {
              const balls = state.balls;
              for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                  const bi = balls[i];
                  const bj = balls[j];
                  const dx = bj.p.x - bi.p.x;
                  const dy = bj.p.y - bi.p.y;
                  const rs = bi.r + bj.r;
                  const distSq = dx * dx + dy * dy;
                  if (distSq === 0) {
                    // Rare pathological overlap: nudge in arbitrary direction
                    const n = { x: 1, y: 0 };
                    const inv1 = 1 / bi.m;
                    const inv2 = 1 / bj.m;
                    const penetration = rs;
                    const percent = 0.8;
                    const slop = 0.01;
                    const corrMag = Math.max(penetration - slop, 0) / (inv1 + inv2) * percent;
                    const cx = n.x * corrMag;
                    const cy = n.y * corrMag;
                    bi.p.x -= cx * inv1; bi.p.y -= cy * inv1;
                    bj.p.x += cx * inv2; bj.p.y += cy * inv2;
                    continue;
                  }
                  if (distSq < rs * rs) {
                    const dist = Math.sqrt(distSq);
                    const nx = dx / dist;
                    const ny = dy / dist;
                    const inv1 = 1 / bi.m;
                    const inv2 = 1 / bj.m;
                    // positional correction to resolve penetration
                    const penetration = rs - dist;
                    const percent = 0.8; // strong separation to avoid sticking
                    const slop = 0.01;
                    const corrMag = Math.max(penetration - slop, 0) / (inv1 + inv2) * percent;
                    const cx = nx * corrMag;
                    const cy = ny * corrMag;
                    bi.p.x -= cx * inv1; bi.p.y -= cy * inv1;
                    bj.p.x += cx * inv2; bj.p.y += cy * inv2;

                    // relative velocity along normal
                    const rvx = bj.v.x - bi.v.x;
                    const rvy = bj.v.y - bi.v.y;
                    const vrn = rvx * nx + rvy * ny;
                    if (vrn < 0) {
                      const e = s.restitution; // reuse bounce for ball-ball
                      const j = -(1 + e) * vrn / (inv1 + inv2);
                      const impX = j * nx;
                      const impY = j * ny;
                      bi.v.x -= impX * inv1; bi.v.y -= impY * inv1;
                      bj.v.x += impX * inv2; bj.v.y += impY * inv2;
                    }
                  }
                }
              }
            }
          }
        }

        function draw() {
          const s = state.settings;
          // background / trails
          if (s.trailAlpha <= 0) {
            ctx.clearRect(0, 0, state.width, state.height);
            ctx.fillStyle = s.bgColor;
            ctx.fillRect(0, 0, state.width, state.height);
          } else {
            ctx.fillStyle = hexToRgba(s.bgColor, s.trailAlpha);
            ctx.fillRect(0, 0, state.width, state.height);
          }

          // polygon
          ctx.save();
          ctx.lineWidth = s.edgeWidth;
          ctx.strokeStyle = 'rgba(255,255,255,0.85)';
          if (s.showPolygonFill) {
            ctx.fillStyle = 'rgba(255,255,255,0.03)';
          }
          const { verts } = buildPolygon(state.theta, s.sides, state.polygonRadiusPx, state.center);
          ctx.beginPath();
          for (let i = 0; i < verts.length; i++) {
            const v = verts[i];
            if (i === 0) ctx.moveTo(v.x, v.y); else ctx.lineTo(v.x, v.y);
          }
          ctx.closePath();
          if (s.showPolygonFill) ctx.fill();
          ctx.stroke();
          ctx.restore();

          // balls
          for (let i = 0; i < state.balls.length; i++) {
            const b = state.balls[i];
            // simple shading
            const grad = ctx.createRadialGradient(b.p.x - b.r * 0.35, b.p.y - b.r * 0.35, b.r * 0.2, b.p.x, b.p.y, b.r);
            grad.addColorStop(0, 'rgba(255,255,255,0.9)');
            grad.addColorStop(0.25, b.color);
            grad.addColorStop(1, 'rgba(0,0,0,0.5)');
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(b.p.x, b.p.y, b.r, 0, TWO_PI);
            ctx.fill();
          }
        }

        function hexToRgba(hex, alpha) {
          const h = hex.replace('#','');
          const bigint = parseInt(h.length === 3 ? h.split('').map(ch=>ch+ch).join('') : h, 16);
          const r = (bigint >> 16) & 255;
          const g = (bigint >> 8) & 255;
          const b = bigint & 255;
          return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function animate(now) {
          const dt = Math.min(0.033, Math.max(0.001, (now - state.lastTime) / 1000));
          state.lastTime = now;
          if (!state.paused) step(dt);
          draw();

          // fps
          state.fpsAccumulator += dt;
          state.fpsFrames++;
          if (state.fpsAccumulator >= 0.5) {
            state.fps = Math.round(state.fpsFrames / state.fpsAccumulator);
            controls.kpi.textContent = `FPS: ${state.fps} | Balls: ${state.balls.length}`;
            state.fpsAccumulator = 0;
            state.fpsFrames = 0;
          }

          requestAnimationFrame(animate);
        }

        function bindUI() {
          const inputs = [
            controls.sides, controls.rotSpeed, controls.count, controls.gravity, controls.restitution,
            controls.wallFriction, controls.minR, controls.maxR, controls.speed, controls.polyRadius,
            controls.edgeWidth, controls.trail, controls.bgColor, controls.showPolygonFill, controls.pause, controls.ballCollisions
          ];
          inputs.forEach(el => {
            el.addEventListener('input', () => {
              const oldCount = state.settings.ballCount;
              updateSettingsFromUI();
              if (el === controls.count || el === controls.minR || el === controls.maxR || el === controls.speed) {
                // recreate balls when cardinal props change
                state.balls = createBalls(state.settings.ballCount);
              } else if (el === controls.polyRadius || el === controls.sides) {
                // keep balls, just adjust boundaries
              }
            });
          });

          controls.reset.addEventListener('click', () => {
            resetSimulation(true);
          });

          controls.randomize.addEventListener('click', () => {
            // randomize a handful of settings for fun
            controls.sides.value = String(Math.floor(randomBetween(3, 13)));
            controls.rotSpeed.value = String(Math.round(randomBetween(-180, 180)));
            controls.gravity.value = String(Math.round(randomBetween(0, 1400)));
            controls.restitution.value = (Math.random() * 0.6 + 0.3).toFixed(2);
            controls.wallFriction.value = (Math.random() * 0.2).toFixed(2);
            controls.minR.value = String(Math.floor(randomBetween(3, 8)));
            controls.maxR.value = String(Math.floor(randomBetween(10, 22)));
            controls.speed.value = String(Math.floor(randomBetween(120, 520)));
            controls.polyRadius.value = String(Math.floor(randomBetween(45, 85)));
            controls.edgeWidth.value = String(Math.floor(randomBetween(1, 5)));
            controls.trail.value = (Math.random() < 0.5 ? 0 : randomBetween(0.04, 0.18)).toFixed(2);
            controls.count.value = String(Math.floor(randomBetween(40, 160)));
            // Apply and recreate
            resetSimulation(true);
          });

          controls.export.addEventListener('click', () => {
            // temporarily render a clean frame without trail alpha for export
            const oldTrail = state.settings.trailAlpha;
            const oldBg = state.settings.bgColor;
            const oldPaused = state.paused;
            state.settings.trailAlpha = 0;
            state.paused = true;
            draw();
            try {
              const url = canvas.toDataURL('image/png');
              const a = document.createElement('a');
              a.href = url;
              a.download = `rotating-polygon-${Date.now()}.png`;
              document.body.appendChild(a);
              a.click();
              a.remove();
            } finally {
              state.settings.trailAlpha = oldTrail;
              state.settings.bgColor = oldBg;
              state.paused = oldPaused;
            }
          });
        }

        // Resize handling
        function onResize() {
          setCanvasSize();
        }
        new ResizeObserver(onResize).observe(document.body);
        window.addEventListener('resize', onResize);

        // Init
        setCanvasSize();
        updateSettingsFromUI();
        state.omega = (state.settings.rotationSpeedDeg * Math.PI / 180);
        state.balls = createBalls(state.settings.ballCount);
        bindUI();
        requestAnimationFrame((t) => { state.lastTime = t; animate(t); });
      })();
    </script>
  </body>
  </html>


